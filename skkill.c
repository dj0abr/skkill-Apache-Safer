/* ===========================================================================

  skkill = (S)kript (K)iddy (Kill)er

Author: Kurt Moraw, Munich, Germany

Date:	20.May 2005
Version:0.1

Date:	18.June 2005
Version:0.11
Changes: fixed: IP address detection if IP adress is at the end of a line.

Date:	23.June 2005
Version:0.12
Changes:1) logs activities into skkill.log
        2) ignores IP addresses from the file noblockIPs
        
Date:   29.Nov 2020
        1) compiler cleanups

==============================================================================

 It is intended for educational purposes only, as a non-commercial test project.
 It may not be used otherwise. Most parts are only experimental.

==============================================================================

 This program is free software; you can redistribute it free of charge
 and/or modify it under the terms of the GNU General Public License as
 published by the Free Software Foundation; either version 2 of the Lcense,
 or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

==============================================================================


Overview: skkill blocks IP addresses automatically
==================================================
   this program scans log files for specific patterns. If a pattern matches, then it looks for an IP address and
   blocks it by entering a DROP statement into iptables.
   You can list all blocked IPs with the command:  iptables -L  or  iptables -L -n 

Configuration:
==============

   this program needs two files in the same path as skkill :
   1) "logFileNames" .... enter the log files to be scanned. Enter the full path. Each filename in a separate line
   2) "searchPattern" ... enter your search patterns into this file. Each pattern in a separate line
   3) optionally the file "noblockIPs" can be used to enter IP addresses which should be ignored (i.e. the local network).
      Enter one IP address by line. Enter only the beginning of an address to specify a group of addresses. I.e.: to ignore all 
      IP addresses of the local network, enter  192.168.

   for sample files you can uncomment the call to generateSampleFiles(). Then sample files will be generated. Edit them for your requirements.

Running skkill:
===============

   skkill do not need any parameters. Just start it in a console:

   ./skkill ... will start skkill. All output will be printed to the standard output.

   ./skkill & ... runs skkill as a daemon in the background. This is the normal operation.

   skkill must run as root

Logging:
========

    If the variable dologging is set to 1, then skkill writes all activities into the file skkill.log

Compiling:
==========

   In the console enter this command line:
   cc skkill.c -o skkill

Additional Information:
=======================

   The file "blockedIPs" stores the blocked IP addresses and the blocking time (hours). 
   DO NOT modify this file ! 
   But it may be useful to read its contents:
   The first number is the blocking time in hours, followed by the IP address.
*/

#include <stdio.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <stdlib.h>

int generateSampleFiles();
int writelog(char *text);
int checkTimeout();
int deleteBlockings();
int blockIP();
int extractIP(char *pline);
int securityCheck(char *pl);
int checkline(char *pl);
int readNewLine(int i, char *fn, char *line);

// =========================================================================================
// ============= these values may be changed if required ===================================
#define MAXIPS		1000			// maximum number of blocked IPs
#define MAXPATTERN	250			// maximum number of patterns in pattern file
#define	MAXLOGFILES	100			// maximum number of log files to be scanned

char	delblocks =	1;			// delete existing blockings when skkill is started  0=do not delete ,   1=delete
int	CHECKTIME =	250000;			// check for new log file entries every xx micro-seconds (10000 = 10ms)
int	MAXTIME =	672;			// maximum block time for IPs in hours (672 = 1 month)
char 	dologging=	1;			// 1=log activities in 'skkilllog',  0=do not log

char *blocked =		{"blockedIPs"};		// file to store blocked IPs (DO NOT edit this file directly)
char *searchpf=		{"searchPattern"};	// file with search patterns (enter your search patterns into this file. Each pattern in a separate line)
char *logfilenames= 	{"logFileNames"};	// file with logfiles to be scanned (enter the log files to be scanned. Enter the full path)
char *skkilllog=	{"/var/www/html/skkill.log"};		// logs activities of skkill if LOG is set to 1
char *neverblock=	{"noblockIPs"};		// List of IPs that should be ignored (each IP address in a new line)
// =========================================================================================

// string length definitions
#define MAXLEN 		2000			// maximum length of one line from a log file
#define	MAXIPLEN	20			// maximum length of an IP adress (with some additional reserve for CR,LF and NULL)
#define IPTABLEN	256			// maximum length of a command line string for iptables

// various global variables
char 	ip[MAXIPLEN] = {""};			// stores an IP address
char 	pattern[MAXPATTERN+1][MAXLEN+1];	// contents of search pattern file
int	pnum=0;					// Number of search patterns
char 	logfiles[MAXLOGFILES+1][MAXLEN+1];	// logfiles to be scanned
int	plog=0;					// Number of logfiles
char	noblockips[MAXPATTERN+1][MAXLEN+1];	// ip addresses to be ignored
int	nbip=0;
int	ignored=0;

int main()
{
FILE *fw,*fr1;
long pos1,pos2;
char line[MAXLEN+1];
char *p;
int i;
char slog[MAXLEN+10000];
int tidx;
time_t timer;
struct tm *ltm;
char date[100];

	// generateSampleFiles(); return 0;   // uncomment to generate sample files

	printf("\n\n skkill: Skript-Kiddy-Killer\n\nblocks crackers by adding their IP to iptables\n\n");
	writelog("\n\nskkill started\n\n");

	// ---- load logfilenames and search pattern into array variables ----

	// read search pattern from file
	if(fr1=fopen(searchpf,"rb"))
	{
		while(fgets(line,MAXLEN,fr1)) 
		{
			if(p=strchr(line,'\n')) *p=0;
			if(p=strchr(line,'\r')) *p=0;
			line[MAXLEN-1]=0;
			if(pnum<MAXPATTERN && line[0]!='#' && strlen(line)>1)	// ignore comments
			{
				strcpy(pattern[pnum++],line);
			}
		}
		fclose(fr1);
	}
	else {
		printf("cannot read search pattern file: %s\n",searchpf);
		return 0;
	}

	printf("Scan for these patterns:\n\n");
	for(i=0; i<pnum; i++) 
	{
		printf("        %s\n",pattern[i]);
	}

	// read log files from file
	if(fr1=fopen(logfilenames,"rb"))
	{
		while(fgets(line,MAXLEN,fr1)) 
		{
			if(p=strchr(line,'\n')) *p=0;
			if(p=strchr(line,'\r')) *p=0;
			line[MAXLEN-1]=0;
			if(plog<MAXLOGFILES && line[0]!='#' && strlen(line)>1)	// ignore comments
			{
				strcpy(logfiles[plog++],line);
			}
		}
		fclose(fr1);
	}
	else {
		printf("cannot read logfilenames file: %s\n",logfilenames);
		return 0;
	}

	printf("\nScan in these files:\n\n");
	for(i=0; i<plog; i++) 
	{
		printf("        %s\n",logfiles[i]);
	}

	// read IPs to be ignored
	if(fr1=fopen(neverblock,"rb"))
	{
		while(fgets(line,MAXLEN,fr1)) 
		{
			if(p=strchr(line,'\n')) *p=0;
			if(p=strchr(line,'\r')) *p=0;
			line[MAXLEN-1]=0;
			if(nbip<MAXPATTERN && line[0]!='#' && strlen(line)>1)	// ignore comments
			{
				strcpy(noblockips[nbip++],line);
			}
		}
		fclose(fr1);
	}

	// ---- delete old blockings (if enabled) ----
	if(delblocks)
		deleteBlockings();

	printf("\nScan ACTIVE. To cancel press Ctrl-C\n");

	// ---- MAIN LOOP: scan files every CHECKTIME seconds in an endless loop ----
	while(1) 
	{
		// Check for new entries in log files
		for(i=0; i<plog; i++) 
		{
			ignored=0;
            *line = 0;
            //printf("check:%d %s\n",i,logfiles[i]);
            if(readNewLine(i,logfiles[i], line)) 
            {
				if(tidx=checkline(line)) 
                {
					if(dologging) 
                    {
						// the IP was blocked. Write information into logfile: skkilllog
						time(&timer);
						ltm=localtime(&timer);
						strcpy(date,asctime(ltm));
						if(strlen(date)>1) date[strlen(date)-1] = 0;
						if(strlen(line)>1) line[strlen(line)-1] = 0;	// remove newline
						sprintf(slog,"BLOCKED %25.25s, IP=%17.17s in %s. catched:[%s] in [%s]\n",date,ip,logfiles[i],pattern[tidx],line);
						writelog(slog);
					}
				}
				if(ignored) 
                {
					// the IP was ignored. Write information into logfile: skkilllog
					time(&timer);
					ltm=localtime(&timer);
					strcpy(date,asctime(ltm));
					if(strlen(date)>1) date[strlen(date)-1] = 0;
					if(strlen(line)>1) line[strlen(line)-1] = 0;	// remove newline
					sprintf(slog,"IGNORED %25.25s, IP=%17.17s in %s. [%s]\n",date,ip,logfiles[i],line);
					writelog(slog);
				}
			}
		}
		// check timeout of blockings
		checkTimeout();
		// wait for "checktime" seconds
		usleep(CHECKTIME);
	}

	// the program will never reach this point since it runs in an endless loop. It can be stopped by pressing Ctrl-C in the console, or with kill if it runs as a daemon.

	return 0;
}

// ========================================================
// Process a line from a logfile
// ========================================================

void removecrlf(char *ln)
{
    int len = strlen(ln);
    if(!len) return;
    for(int i=len-1; i>=0; i--)
    {
        if(ln[i] == '\n' || ln[i] == '\r')
            ln[i] = 0;
        else
            return;
    }
}

char *readLastLine(char *fn)
{
static char ln[MAXLEN+1] = {0};
int ret;

    FILE *fp = fopen(fn,"r");
    if(fp)
    {
        // set to end-offset
        ret = fseek(fp,-MAXLEN,SEEK_END);
        if(ret != 0)
        {
            // set to end-offset impossible, set to start
            ret = fseek(fp,0,SEEK_SET);
        }

        if(ret == 0)
        {
            // read complete block
            char line[MAXLEN+1];
            size_t size = fread(line, 1, MAXLEN, fp);
            if(size == 0) return NULL;
            line[size-1] = 0;
            // remove crlf at the end
            removecrlf(line);
            // seek end of previous line
            char *p = strrchr(line,'\n');
            if(!p) p = strrchr(line,'\r');
            if(!p) return NULL;
            if(strlen(p) < 2) return NULL;
            p++;
            if(!p)
                strcpy(ln,line);
            else
                strcpy(ln,p);
            //printf("last line:<%s>\n",ln);
            return ln;
        }
        
        fclose(fp);
    }
    return NULL;
}

int readNewLine(int i, char *fn, char *line)
{
static char oldln[MAXLOGFILES][MAXLEN+1];
static int f=1;

    if(f)
    {
        f=0;
        memset(oldln,0,MAXLOGFILES * (MAXLEN+1));
    }

    char *newln= readLastLine(fn);
    if(!newln) return 0;
    // is it a new block ?
    if(strcmp(newln,oldln[i]))
    {
        // is new
        //printf("new line:<%s>\n",newln);
        strcpy(oldln[i],newln);
        strcpy(line,newln);
        return 1;
    }
    
    return 0;
}

int checkline(char *pl)
{
int i;

	if(i=securityCheck(pl))					// compare the line with the patterns
	{
		printf("SECURITY ALERT: %s\n",pl);
		if(extractIP(pl))				// if a pattern matches, look for an IP address
		{
			blockIP();				// if an IP has been found, add it to iptables
			return i;
		}
	}
	return 0;
}

// ========================================================
//	Scans the line for security issues, compare it with the patterns
//	return: 0=ok,  1=unsecure
// ========================================================

int securityCheck(char *pl)
{
char *p=NULL;
int i;

	for(i=0; i<pnum; i++) 
	{
        //printf("test:<%s> against <%s> result:",pl,pattern[i]);
		p=strstr(pl,pattern[i]);
		if(p)
			break;
	}

	return (p?i:0);
}

// ========================================================
// extract an IP adress from a line
// and writes it to global variable "ip"
// return: 0=no IP found,   1=IP found
// ========================================================

int extractIP(char *pline)
{
char *p,*start,*end=NULL;
char pl[MAXLEN+1];
int len,i,j,diff;

	len=strlen(pline);
	if(len>MAXLEN) len=MAXLEN;

	strncpy(pl,pline,len);

	p=pl;
	while(1) {
		p=strchr(p,'.');
		if(!p) return 0;
		if(p==pl) return 0;
		if(p==(pl+strlen(pl)-1)) return 0;
		if(*(p-1)>='0' && *(p-1)<='9' && *(p+1)>='0' && *(p+1)<='9')
			break;
	}

	while(--p>pl) {
		if(!(*p>='0' && *p<='9')) 
		{
			p++;
			break;
		}
	}
	start=p;

	if(p=strchr(start,'.'))
	{
		if(p=strchr(++p,'.'))
		{
			if(p=strchr(++p,'.'))
			{
				while(++p<(pl+strlen(pl))) 
				{
					if(!(*p>='0' && *p<='9')) 
					{
						end=p;
						break;
					}
				}
				if(p==(pl+strlen(pl)))
					end=p;
			}
		}
	}

	if(end) {
		*end=0;
		strcpy(ip,start);
	}
	else
		return 0;

	if(nbip==0)
		return 1;

	// check if this IP should be ignored
	for(i=0; i<nbip; i++) {
		diff=0;
		for(j=0; j<strlen(noblockips[i]); j++) {
			if(j>=strlen(ip))
				break;
			if(noblockips[i][j] != ip[j]) {
				diff=1;
				break;
			}
		}
		if(!diff) {
			ignored=1;
			break;
		}
	}
	printf("IP found: %s\n",ip);
	
	return diff;
}

// ========================================================
// Blocks the IP from variable "ip"
// by writing an entry into iptables
// ========================================================
int blockIP()
{
FILE *fp;
char bip[MAXIPLEN+1];
char isblocked=0;
char blockstring[IPTABLEN];
char entry[MAXIPLEN+1];
int time;

	// check if IP is already blocked 
	if(fp=fopen(blocked,"rb")) {
		while(fgets(bip,MAXIPLEN,fp)) {
			bip[MAXIPLEN]=0;
			if(strlen(bip)>=9) {
				sscanf(bip,"%d %s",&time,entry);
				if(strstr(entry,ip))
					isblocked=1;
			}
		}
	}

	// write IP to file "blocked" and to iptables
	if(!isblocked) {
		if(fp = fopen(blocked,"a+b")) {
			fprintf(fp,"0 %s\n",ip);
			fclose(fp);
			sprintf(blockstring,"iptables -I INPUT -s %s -j DROP\n",ip);
			system(blockstring);
			printf("%s",blockstring);
		}
	}
	return 0;
}

// ========================================================
// delete all previous blockings
// ========================================================
int deleteBlockings()
{
FILE *fp;
char bip[MAXIPLEN+1];
char blockstring[IPTABLEN];
char *p;
char entry[MAXIPLEN+1];
int time;

	printf("\nDelete old blockings from iptables\n\n");
	if(fp=fopen(blocked,"rb")) {
		while(fgets(bip,MAXIPLEN,fp)) {
			if(p=strchr(bip,'\n')) *p=0;
			if(p=strchr(bip,'\r')) *p=0;
			bip[MAXIPLEN]=0;
			if(strlen(bip)>=9) {
				sscanf(bip,"%d %s",&time,entry);
				sprintf(blockstring,"iptables -D INPUT -s %s -j DROP\n",entry);
				system(blockstring);
				printf("%s",blockstring);
			}
		}
		fclose(fp);
	}

	// delete blocked IPs from file
	fp=fopen(blocked,"wb");
	fclose(fp);
}

// ========================================================
// Check timeout of blockings, Release IP if older then MAXTIME hours
// ========================================================

int checkTimeout()
{
static int tick=0;
FILE *fr,*fw;
int time[MAXIPS];
char ips[MAXIPS][MAXIPLEN+1];
int idx,i,j;
char blockstring[IPTABLEN];
char bip[MAXIPLEN+1];
char *p;

	if(tick++ > 3600/CHECKTIME) {
		tick=0;
		// comes here every hour

		// read all blocked IPs
		idx=0;
		if(fr=fopen(blocked,"rb")) {
			while(fgets(bip,MAXIPLEN,fr)) {
				if(p=strchr(bip,'\n')) *p=0;
				if(p=strchr(bip,'\r')) *p=0;
				bip[MAXIPLEN]=0;
				if(strlen(bip)>=9) {
					sscanf(bip,"%d %s",&time[idx],ips[idx]);
					idx++;
				}
			}	
			fclose(fr);
		}
		if(!idx)
			return 0;	// nothing to do, no blocked IPs in the list

		// increment time [hours] of each IP
		for(i=0; i<idx; i++) {
			time[i]++;
		}

		// check blocking times for timeout
		for(i=0; i<idx; i++) {
			if(time[i] > MAXTIME) {
				// IPs blocking time is over, delete it from iptables
				printf("Blocktime over, releasing: iptables -D INPUT -s %s -j DROP\n",ips[i]);
				sprintf(blockstring,"iptables -D INPUT -s %s -j DROP\n",ips[i]);
				system(blockstring);
				// remove IP from the list
				for(j=i; j<(idx-1); j++) {
					time[j]=time[j+1];
					strcpy(ips[j],ips[j+1]);
				}
				idx--;
			}
		}	

		// write blocked IPs back to file
		if(fw=fopen(blocked,"wb")) {
			for(i=0; i<idx; i++) {
				fprintf(fw,"%d %s\n",time[i],ips[i]);
			}
			fclose(fw);
		}
	}
}

// write activities to the skkill logfile: skkilllog

int writelog(char *text)
{
FILE *fp;

	if(fp=fopen(skkilllog,"a+b"))
	{
		fprintf(fp,"%s",text);
		fclose(fp);
	}
	else
		printf("cannot open logfile %s\n",skkilllog);
}

// Generate sample configuration files (only if enabled, see main() ).
int generateSampleFiles()
{
FILE *fp;

	if(fp=fopen(searchpf,"wb"))
	{
		fprintf(fp,"POSSIBLE BREAKIN\n");
		fprintf(fp,"Did not receive identification\n");
		fprintf(fp,"Invalid user\n");
		fprintf(fp,"invalid user\n");
		fprintf(fp,"SEARCH /\\x\n");
		fprintf(fp,"slurp\n");
		fprintf(fp,"robots.txt\n");
		fprintf(fp,"cgi-bin\n");
		fprintf(fp,"URI too long\n");

		fclose(fp);
	}

	if(fp=fopen(logfilenames,"wb"))
	{
		fprintf(fp,"/var/log/messages\n");
		fprintf(fp,"/var/log/apache2/access_log\n");
		fprintf(fp,"/var/log/apache2/error_log\n");

		fclose(fp);
	}
}
